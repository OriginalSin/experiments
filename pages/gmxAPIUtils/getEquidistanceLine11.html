<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<meta charset=utf8>
<head>
    <title>SVG Test</title>
</head>
<body>
    <h1>Построение эквидистанты для полигона</h1>
<p>См. <a href="http://www.w3.org/TR/SVG/expanded-toc.html">документацию по SVG</a></p>
<p>Эквидистанта - множество точек, состоящих на расстояние, не большее заданного, от внутренности замкнутого контура с границей, ориентированной по часовой стрелке.</p>
<p>По кнопке <b>Построить</b> строится граница эквидистанты. Повторное нажатие строит эквидистанту контура, проходимого в обратном направлении</p>
<ul>Проблемы
	<li>Эквидистанта незамкнутого контура. Можно замкнуть добавлением к контуру его обращения. Но при этом надо доработать формулы на случай alpha=0 (внешний угол объединенного контура на концах исходного равен 360 градусов)</li>
	<li>Самопересечение контура эквидистанты, когда исходный контур не выпуклый, а расстояние эквидистанты большое. Нужен алгоритм пересчета контура эквидистанты для исключения участков самопересечения</li>
</ul>
<p>В этом варианте программы решена первая проблема. Кроме того, вместо использования сплайна Бизье строится дуга окружности, что соответствует задаче построения эквидистанты</p>
	<div>
 <svg version="1.1" height="500px" width="500px">
<!-- <path d="M 50,100 C 50,50 50,50 100,50 
 	 L 200,50 C 250,50 250,50 250,100
 	 L 250,200 C 250,250 250,250 200,250
 	 L 100,250 C 50,250 50,250 50,200
 	 L 50,100
 "
 	 fill="none" opacity="1" stroke-width="3" stroke="red" id="tt">
 </path> -->
 <-- <path d="M100,100 L 200,100 z" fill=red opacity="1" stroke-width="3" stroke="green" id="tt1"></path>-->
 <path d="M 100,120 A 20,20 0 0,1 100,80 L 200,80 A 20,20 0 0,1 200,120 L 100,120 z" fill=none opacity="1" stroke-width="3" stroke="red" id="tt2"></path>
 </svg>
 		<button id="run">run</button>
	</div>
    <div id="container"/>
    <script type="application/javascript">
        var svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        svg.setAttribute("width", "1000px");
        svg.setAttribute("height", "1000px");
        svg.setAttribute("version", "1.1");

var getEquidistanceLine = function(points, d)
{		// получить обрамление линии
		// строит внешнюю эквидистанту
	var out = [];
	if(points.length) {
		var len = points.length;
		for (var i = 0; i+1 < len; i++) {
			var A = points[i];		// очередная точка А
			var B = points[i+1]; // следующая точка В
			var C = points[i==0 ? len-2 : i-1]; // предыдущая точка C
			var dB = Math.sqrt((B[0]-A[0])*(B[0]-A[0]) + (B[1]-A[1])*(B[1]-A[1])); // длина отрезка AB
			var dC = Math.sqrt((C[0]-A[0])*(C[0]-A[0]) + (C[1]-A[1])*(C[1]-A[1])); // длина отрезка AC
			var B1 = [ A[0] + (B[1] - A[1])*d/dB , A[1] - (B[0] - A[0])*d/dB ]; // точка B' с координатами x1-(y2-y1)*s/dB, y1+(x2-x1)*s/dB
			var C1 = [ A[0] - (C[1] - A[1])*d/dC , A[1] + (C[0] - A[0])*d/dC ]; // точка С' с координатами x1+(y_2-y1)*s/dC, y1-(x_2-x1)*s/dC
			var alpha = - (C[0]-A[0]) *(B[1]- A[1]) + (B[0]-A[0]) * (C[1]-A[1]);
			if (alpha < 0) { // угол CAB острый
				var x = A[0] + ((A[0]-C[0])*dB + (A[0]-B[0])*dC)*d/alpha; // x1+((x1-x_2)/dB+(x1-x2)/dC)*s/alpha
				var y = A[1] + ((A[1]-C[1])*dB + (A[1]-B[1])*dC)*d/alpha;  // y1+((y1-y_2)/dB+(y1-y2)/dC)*s/alpha
				out.push( // A' с координатами
					[x , y , out.length==0 ? ' M ' : ' L ']
				);
			} else { // угол CAB тупой
				out.push( // дуга окружности с центром в точке A от точки C' до точки B' 
					[ C1[0] , C1[1], out.length==0 ? ' M ' : ' L '], // начало дуги в точке C'
					[ d , d , ' A ' ] , // радиус d
					[ 0 , 1 , ' 0 ' ] , // по часовой стрелке
					[ B1[0] , B1[1] , '' ] // конец дуги в точке B'
				);
			}
		}
	}
	out.push([out[0][0] , out[0][1] , ' L ']);
	return out;
}
		
var points = [
	[42, 27] 
	,[112 + 150, 127 + 200] 
	,[242 + 100, 47 + 120] 
	//,[112 + 150, 127 + 200] 
	,[42, 27] 
];
var points = [
 [100, 100] 
 ,[200, 100] 
 ,[100, 100] 
];
var points = [
 [100, 200] 
 ,[250, 50] 
 ,[200, 180] 
 ,[300, 200] 
 ,[100, 200] 
];
/*
var points = [
 [100, 200] 
 ,[100, 100] 
 ,[150, 100] 
 ,[150, 150] 
 ,[200, 150] 
 ,[200, 200] 
 ,[100, 200] 
];*/
	var newpath = document.createElementNS("http://www.w3.org/2000/svg", "path");  
	newpath.setAttribute("id", "pathIdD");  
	newpath.setAttribute("stroke", "red");  
	newpath.setAttribute("stroke-width", 3);  
	newpath.setAttribute("opacity", 1);  
	newpath.setAttribute("fill", "none");
	var str = 'M ' + points[0][0] + ',' + points[0][1] + ' ';
	for (var i = 0, len = points.length; i < len; i++) {
		var p = points[i];
		str += ' ' + (p[2] ? p[2] : 'L') + ' ' + p[0] + ',' + p[1];
	 }
	 newpath.setAttribute("d", str);  
	svg.appendChild(newpath);
	document.getElementById("container").appendChild(svg);

document.getElementById("run").onclick = function()
{
	var pathIdD1 = document.getElementById("pathIdD1");
	if(pathIdD1) pathIdD1.parentNode.removeChild(pathIdD1);
	var lineRes = getEquidistanceLine(points.reverse(), 20);
	//var lineRes = getEquidistanceLine(points, 20);
	var newpath1 = document.createElementNS("http://www.w3.org/2000/svg", "path");  
	newpath1.setAttribute("id", "pathIdD1");  
	newpath1.setAttribute("stroke", "blue");  
	newpath1.setAttribute("stroke-width", 3);  
	newpath1.setAttribute("opacity", 1);  
	newpath1.setAttribute("fill", "none");
	var str = '';
	for (var i = 0, len = lineRes.length; i < len; i++) {
		var p = lineRes[i];
		str += ' ' + p[2] + ' ' + p[0] + ',' + p[1];
	}
	newpath1.setAttribute("d", str);  
	//newpath1.setAttribute("d", "M 1,97.857143 C 19.285714,96.428571 24.016862,131.64801 90.714286,132.85714 140.78762,133.7649 202.79376,66.16041 202.79376,66.16041");  
    svg.appendChild(newpath1);
/*	
var shape = document.createElementNS("http://www.w3.org/2000/svg", "circle");  
shape.setAttributeNS(null, "cx", 25);
shape.setAttributeNS(null, "cy", 25);
shape.setAttributeNS(null, "r",  20);
shape.setAttributeNS(null, "fill", "green");	
    svg.appendChild(shape);
*/
}
    </script>
  </body>
</html>